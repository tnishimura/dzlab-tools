#!/usr/bin/env perl
use strict;
use warnings FATAL => "all";
use 5.010_000;
use Data::Dumper;
use autodie;
use Pod::Usage;
use Getopt::Long;
use FindBin;
use lib "$FindBin::Bin/lib";
use FastaReader;
use FastaUtil;
use FastaReader::BaseComposition;

END {close STDOUT}
$| = 1;

use File::Basename qw/basename/;
$0 = basename $0;

sub usage{
    print <<"END";
usage:

Get the lengths of chromosomes in fasta file:

  $0 lengths data.fasta               
  $0 lengths --gff data.fasta # in gff format
  $0 len data.fasta           # "lengths" can be abbrev'd to "len" or even "l"

Get a subsection of the fasta file:

  $0 get --sequence chr1 data.fasta      # output chr1 from data.fasta
  $0 get -s chr1 -r 21 30 data.fasta     # output chr1 base 21 to 30 
  $0 get -s chr1 -r 21 30 -rc data.fasta # output chr1 base 21 to 30 rc'd
  $0 get -s chr1 -rc -c2t data.fasta     # bsrc chr1
  $0 get -s chr1 -rc -g2a data.fasta     # bsrc chr1
  $0 get data.fasta                      # do... nothing, just print 

Get base composition (bc) of fasta file:

  $0 base-composition -m 1 data.fasta # single nucleotide counts
  $0 bc -m 1 data.fasta               # short form
  $0 bc -m 1 -v data.fasta            # be verbose (show progress)
  $0 bc -m 3 data.fasta               # all contexts up to 3 nucleotides
  $0 bc data.fasta                    # same as above (3 is default)

  Note: this only counts the forward strand, since 

Get methyl context composition (mc) of fasta file:

  $0 methylation-context data.fasta   # 
  $0 mc data.fasta                    # 

  Note: this counts both strands, b/c CHG/CHH is not symmetric. CG 
        should be double the number given by the bc command, since that
        one only counts one strand.

Test if two fasta files have equal content.

  $0 eq file1.fasta file2.fasta

Convert:

  $0 rc input.fasta output.fasta
  $0 bs -c2t input.fasta output.fasta
  $0 bs -g2a input.fasta output.fasta
  $0 bsrc -c2t input.fasta output.fasta
  $0 bsrc -g2a input.fasta output.fasta

END

    exit 1;
}

my $cmd = shift;

given ($cmd){
    when ([qw/lengths length len l/]){
        my $result = GetOptions (
            "gff|g" => \(my $gff),
        );
        usage() if (!$result || !@ARGV);

        for my $fasta (@ARGV) {
            say $fasta;
            my $r = FastaReader->new(file => $fasta, slurp => 0);

            my %lengths = $r->sequence_lengths;

            my $total = 0;
            for (sort keys %lengths){
                if ($gff){
                    say join "\t", $_, '.', 'chromosome', 1, $lengths{$_}, qw/. . ./, "Name=$_";
                }
                else{
                    say "$_:\t" . $lengths{$_};
                }
                $total += $lengths{$_};
            }
            if (! $gff){
                say "total:\t" . $total; 
            }
        }
    }
    when ([qw/base-composition bc/]){
        my $result = GetOptions (
            "max|m=i"      => \(my $max = 3),
            "verbose|v"    => \$FastaReader::BaseComposition::VERBOSE,
        );
        usage() if ! $result;

        my $fasta = shift || usage();
        FastaReader::BaseComposition::report($fasta, $max);
    }
    when ([qw/methylation-contexts mc/]){
        my $result = GetOptions (
            "max|m=i"      => \(my $max = 3),
            "verbose|v"    => \$FastaReader::BaseComposition::VERBOSE,
        );
        usage() if ! $result;

        my $fasta = shift || usage();
        FastaReader::BaseComposition::report($fasta, 3, 1);
    }
    when ([qw/get/]){
        my @range;
        my $result = GetOptions (
            "sequence|seq=s" => \(my $sequence),
            "range|r=i{2}"   => \@range,
            "coordinate|c=s" => \(my $coordinate = 'f'),
            "base|b=i"       => \(my $base = 1),
            "c2t"            => \(my $c2t),
            "g2a"            => \(my $g2a),
            "reverse-complement|rc" => \(my $reverse_complement),
        );
        usage() if (
            ! $result || 
            ! $sequence ||
            (@range != 0 && @range != 2) ||
            ($coordinate ne 'f' && $coordinate ne 'r') ||
            ($base != 0 && $base != 1) || 
            ($c2t && $g2a)
        );  

        my $fasta = shift || usage();
        my $r = FastaReader->new(file => $fasta, slurp => 0);
        my @bsarg = ($c2t ? (bs => 'c2t') : $g2a ? (bs => 'g2a') : ());

        if (0 == @range){
            print $r->get_pretty(
                $sequence, # label
                $sequence, 
                undef, 
                undef, 
                rc    => $reverse_complement,
                @bsarg,
            );
        }
        else{
            print $r->get_pretty(
                "$sequence\_$range[0]\_$range[1]", 
                $sequence, @range,
                coord => $coordinate,
                rc    => $reverse_complement,
                base  => $base,
                @bsarg,
            );
        }
    }
    # when (qw/split/){
    # }
    when ([qw/bsrc bs/]){
        my $result = GetOptions (
            "c2t|c2t" => \(my $c2t),
            "g2a|g2a" => \(my $g2a),
        );
        if (! $result || ! ($c2t xor $g2a) || @ARGV != 2){
            say "usage: $0 bs   [-c2t | -g2a ]  input.fasta output.fasta";
            say "       $0 bsrc [-c2t | -g2a ]  input.fasta output.fasta";
            exit 1;
        }
        if ($_ eq 'bsrc'){
            bsrc_fasta_on_disk($c2t ? 'c2t' : 'g2a', @ARGV);
        }
        else{
            bs_fasta_on_disk($c2t ? 'c2t' : 'g2a', @ARGV);
        }
    }
    when ('rc'){
        if (@ARGV != 2){
            say "usage: $0 rc input.fasta output.fasta";
            exit 1;
        }
        rc_fasta_on_disk(@ARGV);
    }
    when ('eq'){
        if (@ARGV != 2){
            say "usage: $0 eq first.fasta second.fasta";
            exit 1;
        }

        my ($success, $msg) = fasta_eq(@ARGV);
        if ($success){
            say STDERR 'equal';
            exit 0;
        }
        else{
            say STDERR "not equal: $msg";
            exit 1;
        }
    }
    default{
        usage();
    }
}
