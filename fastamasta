#!/usr/bin/env perl
use strict;
use warnings FATAL => "all";
use 5.010_000;
use Data::Dumper;
use autodie;
use Pod::Usage;
use Getopt::Long;
use FindBin;
use lib "$FindBin::Bin/lib";
use FastaReader;
use FastaUtil;
use FastaReader::BaseComposition;
use DZUtil qw/reverse_complement/;

END {close STDOUT}
$| = 1;

use File::Basename qw/basename/;
$0 = basename $0;

sub usage{
    print <<"END";
usage:

Get the lengths of chromosomes in fasta file:

  $0 lengths data.fasta               
  $0 lengths --gff data.fasta # in gff format
  $0 len data.fasta           # "lengths" can be abbrev'd to "len" or even "l"

Get a subsection of the fasta file:

  $0 get --sequence chr1 data.fasta      # output chr1 from data.fasta
  $0 get -s chr1 -r 21 30 data.fasta     # output chr1 base 21 to 30 
  $0 get -s chr1 -r 21 30 -rc data.fasta # output chr1 base 21 to 30 rc'd
  $0 get -s chr1 -rc -c2t data.fasta     # bsrc chr1
  $0 get -s chr1 -rc -g2a data.fasta     # bsrc chr1
  $0 get data.fasta                      # do... nothing, just print 

Get base composition (bc) of fasta file:

  $0 base-composition -m 1 data.fasta # single nucleotide counts
  $0 bc -m 1 data.fasta               # short form
  $0 bc -m 1 -v data.fasta            # be verbose (show progress)
  $0 bc -m 3 data.fasta               # all contexts up to 3 nucleotides
  $0 bc data.fasta                    # same as above (3 is default)

  Note: this only counts the forward strand, since 

Get methyl context composition (mc) of fasta file:

  $0 methylation-context data.fasta   # 
  $0 mc data.fasta                    # 

  Note: this counts both strands, b/c CHG/CHH is not symmetric. CG 
        should be double the number given by the bc command, since that
        one only counts one strand.

Test if two fasta files have equal content.

  $0 eq file1.fasta file2.fasta

Convert:

  $0 rc input.fasta output.fasta
  $0 bs -c2t input.fasta output.fasta
  $0 bs -g2a input.fasta output.fasta
  $0 bsrc -c2t input.fasta output.fasta
  $0 bsrc -g2a input.fasta output.fasta

Search (for exact match):
  # look for ACTGTTACCATG in input.fasta
  $0 find -s ACTGTTACCATG input.fasta  

  # look for seqs in search.fasta in input.fasta
  $0 find -f search.fasta input.fasta  

  # can be combined:
  $0 find -s ACGT -f file_containing_seq.fasta input.fasta 

  # set all features (column 3) to "MEOW" in output:
  $0 find -s ACGT --feature MEOW input.fasta     

  # set all attributes (column 3) to "ID=AT123" in output:
  $0 find -s ACGT --attribute "ID=AT123" input.fasta

END

    exit 1;
}

my $cmd = shift;

for ($cmd){
    when ([qw/lengths length len l/]){
        my $result = GetOptions (
            "gff|g" => \(my $gff),
        );
        usage() if (!$result || !@ARGV);

        for my $fasta (@ARGV) {
            say $fasta;
            my $r = FastaReader->new(file => $fasta, slurp => 0);

            my %lengths = $r->sequence_lengths;

            my $total = 0;
            for (sort keys %lengths){
                if ($gff){
                    say join "\t", $_, '.', 'chromosome', 1, $lengths{$_}, qw/. . ./, "Name=$_";
                }
                else{
                    say "$_:\t" . $lengths{$_};
                }
                $total += $lengths{$_};
            }
            if (! $gff){
                say "total:\t" . $total; 
            }
        }
    }
    when ([qw/base-composition bc/]){
        my $result = GetOptions (
            "max|m=i"      => \(my $max = 3),
            "verbose|v"    => \$FastaReader::BaseComposition::VERBOSE,
        );
        usage() if ! $result;

        my $fasta = shift || usage();
        FastaReader::BaseComposition::report($fasta, $max);
    }
    when ([qw/methylation-contexts mc/]){
        my $result = GetOptions (
            "max|m=i"      => \(my $max = 3),
            "verbose|v"    => \$FastaReader::BaseComposition::VERBOSE,
        );
        usage() if ! $result;

        my $fasta = shift || usage();
        FastaReader::BaseComposition::report($fasta, 3, 1);
    }
    when ([qw/reverse-coord reverse-coordinate/]){
        my @range;
        my $result = GetOptions (
            "sequence|seq=s" => \(my $sequence),
            "range|r=i{2}"   => \@range,
            "base|b=i"       => \(my $base = 1),
        );
        usage() if (
            ! $result || 
            ! $sequence ||
            (@range != 0 && @range != 2)
        );  

        my $fasta = shift || usage();
        my $r = FastaReader->new(file => $fasta, slurp => 0);
        say 
        $r->forward2reverse($sequence, $range[1], $base), "\t", 
        $r->forward2reverse($sequence, $range[0], $base);
    }
    when ([qw/get/]){
        my @range;
        my $result = GetOptions (
            "sequence|seq=s" => \(my $sequence),
            "range|r=i{2}"   => \@range,
            "coordinate|c=s" => \(my $coordinate = 'f'),
            "base|b=i"       => \(my $base = 1),
            "c2t"            => \(my $c2t),
            "g2a"            => \(my $g2a),
            "reverse-complement|rc" => \(my $reverse_complement),
        );
        usage() if (
            ! $result || 
            ! $sequence ||
            (@range != 0 && @range != 2) ||
            ($coordinate ne 'f' && $coordinate ne 'r') ||
            ($base != 0 && $base != 1) || 
            ($c2t && $g2a)
        );  

        my $fasta = shift || usage();
        my $r = FastaReader->new(file => $fasta, slurp => 0);
        my @bsarg = ($c2t ? (bs => 'c2t') : $g2a ? (bs => 'g2a') : ());

        if (0 == @range){
            print $r->get_pretty(
                $sequence, # label
                $sequence, 
                undef, 
                undef, 
                rc    => $reverse_complement,
                @bsarg,
            );
        }
        else{
            print $r->get_pretty(
                "$sequence\_$range[0]\_$range[1]", 
                $sequence, @range,
                coord => $coordinate,
                rc    => $reverse_complement,
                base  => $base,
                @bsarg,
            );
        }
    }
    # when (qw/split/){
    # }
    when ([qw/bsrc bs/]){
        my $result = GetOptions (
            "c2t|c2t" => \(my $c2t),
            "g2a|g2a" => \(my $g2a),
        );
        if (! $result || ! ($c2t xor $g2a) || @ARGV != 2){
            say "usage: $0 bs   [-c2t | -g2a ]  input.fasta output.fasta";
            say "       $0 bsrc [-c2t | -g2a ]  input.fasta output.fasta";
            exit 1;
        }
        if ($_ eq 'bsrc'){
            bsrc_fasta_on_disk($c2t ? 'c2t' : 'g2a', @ARGV);
        }
        else{
            bs_fasta_on_disk($c2t ? 'c2t' : 'g2a', @ARGV);
        }
    }
    when ('rc'){
        if (@ARGV != 2){
            say "usage: $0 rc input.fasta output.fasta";
            exit 1;
        }
        rc_fasta_on_disk(@ARGV);
    }
    when ('eq'){
        if (@ARGV != 2){
            say "usage: $0 eq first.fasta second.fasta";
            exit 1;
        }

        my ($success, $msg) = fasta_eq(@ARGV);
        if ($success){
            say STDERR 'equal';
            exit 0;
        }
        else{
            say STDERR "not equal: $msg";
            exit 1;
        }
    }
    # like eq but with 
    when ('geteq'){
        my @range1;
        my @range2;
        my $result = GetOptions (
            "sequence-1|s1=s" => \(my $sequence1),
            "sequence-2|s2=s" => \(my $sequence2),
            "range-1|r1=i{2}"   => \@range1,
            "range-2|r2=i{2}"   => \@range2,
            "coordinate|c=s" => \(my $coordinate = 'f'),
            "base|b=i"       => \(my $base = 1),
            "c2t"            => \(my $c2t),
            "g2a"            => \(my $g2a),
        );
        usage() if (
            ! $result || 
            ! $sequence1 ||
            ! $sequence2 ||
            (@range1 != 0 && @range2 != 2) ||
            (@range2 != 0 && @range2 != 2) ||
            ($coordinate ne 'f' && $coordinate ne 'r') ||
            ($base != 0 && $base != 1) || 
            ($c2t && $g2a)
        );  

        my ($f1, $f2) = @ARGV;
        usage() unless defined $f1 && defined $f2;

        my $f1r = FastaReader->new(file => $f1, slurp => 0);
        my $f2r = FastaReader->new(file => $f2, slurp => 0);

        my @bsarg = ($c2t ? (bs => 'c2t') : $g2a ? (bs => 'g2a') : ());

        my $s1 = $f1r->get($sequence1, @range1, @bsarg, coord => $coordinate, base => $base);
        my $s2 = $f2r->get($sequence2, @range2, @bsarg, coord => $coordinate, base => $base);
        if ($s1 eq $s2){ 
            say "equal"; 
        }
        else { 
            say "not equal"; 
        }
    }
    when ('find'){
        my $result = GetOptions (
            "fasta|f=s"    => \(my $file),
            "sequence|s=s" => \(my $sequence),
            "rc"           => \(my $rc),
            "feature|3=s"    => \(my $feature),
            "attribute|9=s"  => \(my $attribute),
        );
        my $input = shift @ARGV;
        usage() if (!$result || ! $input || ! -f $input);  

        $feature //= '.';
        $attribute //= '.';

        my @search;
        if (defined $file and -f $file){
            my $fr = FastaReader->new(file => $file, slurp => 0);
            for my $seq ($fr->sequence_list()) {
                push @search, $fr->get($seq, undef, undef);
                if ($rc){
                    push @search, $fr->get($seq, undef, undef, rc => 1);
                }
            }
        }
        if (defined $sequence){
            push @search, $sequence;
        }

        my $input_fr = FastaReader->new(file => $input, slurp => 1);

        for my $match ($input_fr->find(@search)) {
            my ($seqid, $start, $end, $rc) = @$match;
            say join "\t", $seqid, qw/./, $feature, $start, $end, q/./, ($rc ? '-' : '+'), qw/./, $attribute;
        }
    }
    default{
        usage();
    }
}
